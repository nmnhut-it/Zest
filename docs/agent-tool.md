# Tool-Calling Autonomous Code Exploration Agent

## Overview

This document describes the enhanced tool-calling system that transforms the autonomous code exploration agent from asking abstract questions to taking concrete actions through tool execution.

## Architecture

```
User Query → Agent decides tool → Execute tool → 
Feed results back → Agent reasons → Repeat/Conclude
```

## Core Components

### 1. Tool Registry System (`CodeExplorationToolRegistry.java`)

Central registry for all code exploration tools with:
- Tool metadata (name, description, parameters)
- Tool execution interface
- Dynamic tool registration

### 2. Tool Implementations

#### SearchCodeTool
- Wraps `CodeSearchUtility.searchRelatedCode()`
- Performs hybrid search across name, semantic, and structural indices
- Returns enriched search results

#### FindByNameTool
- Direct access to `NameIndex.search()`
- Fast identifier-based search
- CamelCase-aware matching

#### FindSimilarTool
- Semantic search via `SemanticIndex.findSimilar()`
- Vector-based similarity search
- Returns semantically related code

#### FindRelationshipsTool
- Uses `StructuralIndex.findAllRelated()`
- Finds callers, implementations, inheritance
- Returns structured relationship data

#### ReadFileTool
- Read file contents using IntelliJ PSI
- Returns full file content with metadata

#### FindCallersTool
- Find all methods that call a specific method
- Uses structural index for fast lookup

#### FindImplementationsTool
- Find all implementations of interfaces/abstract methods
- Includes inheritance hierarchy

### 3. Tool Call Parser (`ToolCallParser.java`)

Parses LLM's structured tool call responses:
- Validates tool calls
- Handles errors gracefully
- Supports batch tool execution

### 4. Enhanced Exploration Agent (`ToolCallingAutonomousAgent.java`)

Replaces question-based exploration with tool-based actions:
- Maintains exploration context and history
- Builds concrete knowledge graph
- Generates actionable insights

## Tool Call Flow

```java
// Example tool call generated by LLM:
{
  "tool": "search_code",
  "parameters": {
    "query": "CodeSearchUtility performance optimization",
    "maxResults": 5
  },
  "reasoning": "Need to understand how performance is optimized in search"
}
```

## Enhanced Prompts Structure

Instead of abstract questions, the agent generates concrete tool calls:
- "I need to find the implementation of X" → `find_by_name("X")`
- "Show me what calls this method" → `find_callers("method_id")`
- "Find similar implementations" → `find_similar("element_id")`

## UI/UX Improvements

### Real-time Progress Visualization
- Current tool being executed
- Exploration tree/graph display
- Progress indicators for each phase

### Interactive Exploration Report
- Collapsible sections for each exploration round
- Syntax-highlighted code snippets
- Clickable code references that navigate to source
- Visual dependency graphs

### Exploration Controls
- Pause/Resume exploration
- Skip to summary
- Adjust exploration depth dynamically
- Filter results by type (code, insights, relationships)

## Example Enhanced Exploration Session

```
User: "How does CodeSearchUtility handle hybrid search?"

Round 1:
- Tool: find_by_name("CodeSearchUtility")
- Result: Found class at com.zps.zest.langchain4j.CodeSearchUtility
- Tool: read_file("CodeSearchUtility.java")
- Result: [Full class content]

Round 2:
- Tool: find_method("performHybridSearch")
- Result: Found method with signature...
- Tool: find_callers("performHybridSearch")
- Result: Called by searchRelatedCode()

Round 3:
- Tool: find_relationships("HybridSearchResults")
- Result: Used by enrichResults(), contains CombinedSearchResult...
```

## Implementation Classes

### CodeExplorationTool Interface
```java
public interface CodeExplorationTool {
    String getName();
    String getDescription();
    JsonObject getParameterSchema();
    ToolResult execute(JsonObject parameters);
}
```

### ToolResult Class
```java
public class ToolResult {
    private final String content;
    private final Map<String, Object> metadata;
    private final List<String> codeReferences;
    private final boolean success;
    private final String error;
}
```

### ExplorationContext Class
```java
public class ExplorationContext {
    private final Map<String, ToolResult> toolHistory;
    private final Set<String> exploredElements;
    private final Map<String, List<String>> relationships;
    private final List<String> insights;
}
```

## Benefits

1. **Concrete Actions**: Instead of abstract questions, the agent takes specific actions
2. **Verifiable Results**: Each tool call produces tangible results
3. **Better Context**: Tool results provide actual code and relationships
4. **Improved UX**: Users see exactly what the agent is doing
5. **Faster Exploration**: Direct access to indices vs. repeated searches

## Configuration

The tool-calling system can be configured through:
- Tool selection and availability
- Exploration depth limits
- Result filtering and ranking
- UI display preferences

## Implementation Status

### Completed Components

1. **Core Infrastructure**
   - `CodeExplorationTool` interface
   - `CodeExplorationToolRegistry` - Central tool registry
   - `BaseCodeExplorationTool` - Base class for tools
   - `ToolCallParser` - Parses LLM tool calls from various formats

2. **Implemented Tools**
   - `SearchCodeTool` - Hybrid search across indices
   - `FindByNameTool` - Name-based identifier search
   - `FindSimilarTool` - Semantic similarity search
   - `FindRelationshipsTool` - Structural relationships
   - `ReadFileTool` - File content reading
   - `FindCallersTool` - Find method callers
   - `FindImplementationsTool` - Find implementations
   - `FindMethodsTool` - List class methods
   - `GetClassInfoTool` - Detailed class information
   - `ListFilesInDirectoryTool` - Directory listing
   - `GetCurrentContextTool` - Current editor context
   - `FindUsagesTool` - Find element usages

3. **Agent Implementation**
   - `ToolCallingAutonomousAgent` - Main tool-calling agent
   - Planning, exploration, and summary phases
   - Tool execution with error handling
   - Context tracking and result aggregation

4. **UI Components**
   - `TestToolCallingAgentAction` - Test action with progress dialog
   - `ToolExplorationPanel` - Enhanced UI panel with:
     - Real-time tool execution display
     - Exploration graph visualization
     - Code reference navigation
     - Multi-tab interface

## Usage Examples

### Basic Usage

```java
// Get the agent service
ToolCallingAutonomousAgent agent = project.getService(ToolCallingAutonomousAgent.class);

// Execute exploration
ExplorationResult result = agent.exploreWithTools("How does the payment system work?");

// Process results
for (ExplorationRound round : result.getRounds()) {
    for (ToolExecution execution : round.getToolExecutions()) {
        System.out.println("Tool: " + execution.getToolName());
        System.out.println("Result: " + execution.getResult());
    }
}
```

### Custom Tool Implementation

```java
public class CustomTool extends BaseCodeExplorationTool {
    public CustomTool(Project project) {
        super(project, "custom_tool", "Description of custom tool");
    }
    
    @Override
    public JsonObject getParameterSchema() {
        JsonObject schema = new JsonObject();
        // Define parameters
        return schema;
    }
    
    @Override
    protected ToolResult doExecute(JsonObject parameters) {
        // Implement tool logic
        return ToolResult.success("Result content", createMetadata());
    }
}
```

### Tool Registration

```java
CodeExplorationToolRegistry registry = project.getService(CodeExplorationToolRegistry.class);
registry.register(new CustomTool(project));
```

## Testing

1. Use the "Test Tool-Calling Agent" action from the Tools menu
2. Enter a query about code functionality
3. Watch real-time tool execution progress
4. Review exploration results and discovered code elements

## Future Enhancements

1. **Tool Chaining**: Automatic tool sequences for common patterns
2. **Learning**: Remember successful tool sequences for similar queries
3. **Custom Tools**: User-defined tools for project-specific exploration
4. **Advanced Visualization**: 
   - Interactive graph visualization using D3.js
   - Code relationship diagrams
   - Tool execution timeline
5. **Export Features**:
   - Generate Markdown documentation
   - Export to PlantUML diagrams
   - Create exploration reports
6. **Performance Optimization**:
   - Parallel tool execution
   - Result caching
   - Incremental exploration
7. **Integration**:
   - IDE navigation from results
   - Bookmarking interesting findings
   - Sharing exploration sessions
