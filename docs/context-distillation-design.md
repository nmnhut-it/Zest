# Context Distillation Design for Test Generation

## Overview
This document describes a two-tier context system for the test generation agents, using LLM-powered distillation to create both quick overview access and detailed deep-dive capabilities.

## Current State
The `ContextAgent` now captures complete, unprocessed information including:
- Build files and dependencies
- Analyzed classes with full source code
- Related files and configurations
- Code patterns and usage examples
- Context notes about behaviors and contracts

## Proposed Context Distillation System

### 1. Two-Tier Architecture

#### Tier 1: Distilled Context (LLM-Generated Summary)
- **Purpose**: Provide immediate understanding needed to write new code that fits perfectly
- **Content** (generated by LLM from full context):

  - **Code Templates & Patterns**:
    - Class structure templates (how classes are organized)
    - Method patterns (validation, error handling, logging)
    - Naming conventions (variables, methods, classes, tests)
    - Package structure rules
    - Import organization patterns

  - **Project-Specific Conventions**:
    - Dependency injection patterns used
    - Transaction boundary patterns
    - Validation approaches
    - Error handling philosophy
    - Logging patterns and levels
    - Security/authorization patterns

  - **Data & Integration Patterns**:
    - Data access patterns (repository methods, query patterns)
    - Entity/DTO patterns and conversions
    - External service call patterns
    - Message/event patterns
    - API endpoint patterns
    - Configuration patterns

  - **Testing Patterns**:
    - Test structure templates
    - Mock vs real component usage
    - Test data creation patterns
    - Assertion styles used
    - Test naming conventions
    - Setup/teardown patterns

  - **Dependencies & Frameworks**:
    - Testing frameworks and exact versions
    - Core libraries and their actual usage
    - Build system and dependencies
    - Project-specific utilities always used

  - **Critical Business Context**:
    - Domain terminology and meanings
    - Business rules and validations
    - Workflows and state machines
    - Calculations and algorithms
    - Input/output formats

#### Tier 2: Full Context (Complete Information)
- **Purpose**: Complete information for detailed analysis
- **Content**:
  - **Build & Dependencies**:
    - Full build files (pom.xml, build.gradle, etc.)
    - JAR files in lib folders
    - Dependency trees with versions
  - **Code Analysis**:
    - Complete analyzed classes with source
    - Method signatures and relationships
    - Call hierarchies
  - **Related Files**:
    - Configuration files (properties, YAML, XML)
    - Database schemas/migrations
    - API specifications
    - Resource files
  - **Context Notes**:
    - All technical findings
    - Behavioral observations
    - Constraints and requirements

### 2. Storage Structure in ContextGatheringTools

```java
public class ContextGatheringTools {
    // Full Context Storage (Already exists)
    private final Map<String, String> analyzedClasses;  // Full class analysis
    private final Map<String, String> readFiles;        // All files read
    private final List<String> contextNotes;            // All findings

    // Distilled Context (New - LLM Generated)
    private String distilledSummary;     // LLM-generated overview
    private String distilledPatterns;    // Key patterns and approaches
    private String distilledDependencies;// Categorized deps with purposes
    private String distilledBehaviors;   // Critical behaviors and rules

    // Access methods
    public String getDistilledContext() {
        // Returns LLM-distilled summary
    }

    public Map<String, String> getFullAnalyzedClasses() {
        // Returns complete class analyses
    }

    public String getSpecificContext(String key) {
        // Returns specific full context piece
    }
}
```

### 3. Context Access Patterns

#### For ContextAgent (Initial Gathering)
```java
// Gather everything
String fullContent = readFile("pom.xml");
// Store both full and distilled
contextNotes.add("[DISTILLED] " + distillDependencies(fullContent));
fullContextStore.put("pom.xml", fullContent);
```

#### For TestWriterAgent (Quick Access)
```java
// Get distilled context first
String distilled = contextTools.getDistilledContext();
// Use for initial test generation decisions

// If specific dependency details needed:
String pomContent = contextTools.getFullBuildFile("pom.xml");
```

#### For AITestMergerAgent (Deep Analysis)
```java
// Access full context when validating dependencies
String allDependencies = contextTools.getFullDependencies();
// Use for resolving validation errors and understanding versions
```

### 4. LLM-Based Distillation Process

```java
@Tool("Distill the gathered context into a concise summary for quick access")
public String distillContext() {
    // Prepare full context for LLM
    StringBuilder fullContext = new StringBuilder();

    // Add all analyzed classes
    fullContext.append("=== ANALYZED CLASSES ===\n");
    for (Entry<String, String> entry : analyzedClasses.entrySet()) {
        fullContext.append("Class: ").append(entry.getKey()).append("\n");
        fullContext.append(entry.getValue()).append("\n\n");
    }

    // Add all context notes
    fullContext.append("=== CONTEXT NOTES ===\n");
    for (String note : contextNotes) {
        fullContext.append(note).append("\n");
    }

    // Add key files
    fullContext.append("=== KEY FILES ===\n");
    for (Entry<String, String> entry : readFiles.entrySet()) {
        if (isCriticalFile(entry.getKey())) {
            fullContext.append("File: ").append(entry.getKey()).append("\n");
            fullContext.append(entry.getValue()).append("\n\n");
        }
    }

    // Call LLM to distill
    String prompt = """
        Analyze this complete context and create a distilled summary for code generation.
        Focus on what a developer needs to write NEW code that fits perfectly into this codebase.

        1. CODE TEMPLATES & PATTERNS (200 words)
        - Exact class structure templates (field order, method order, annotations)
        - Method patterns (how methods are structured, error handling, validation)
        - Naming conventions for everything (variables, methods, classes, packages, tests)
        - Import organization and commonly used imports
        - Code organization patterns within files

        2. PROJECT CONVENTIONS (200 words)
        - How dependencies are injected/managed
        - Transaction patterns and boundaries
        - Validation approaches (where and how)
        - Error handling patterns (exceptions used, when thrown)
        - Logging patterns (what's logged, at what level, format)
        - Security/authorization patterns if present
        - Common utility methods always used

        3. DATA & INTEGRATION PATTERNS (150 words)
        - Data access patterns (query naming, return types)
        - Entity/DTO/Model patterns and conversions
        - External service call patterns
        - API endpoint patterns and conventions
        - Configuration patterns
        - Database interaction patterns

        4. TESTING PATTERNS (150 words)
        - Test class structure and organization
        - Test method naming conventions
        - Mock vs real component patterns
        - Test data creation patterns
        - Assertion patterns and preferred libraries
        - Setup/teardown patterns
        - Integration vs unit test boundaries

        5. DEPENDENCIES & BUILD (100 words)
        - Testing framework and exact version
        - Key libraries and their actual usage in code
        - Build system specifics
        - Project-specific utilities that are frequently used

        6. BUSINESS CONTEXT (100 words)
        - Domain terminology (what terms mean in this context)
        - Critical business rules that affect code
        - Workflows and state machines
        - Important calculations or algorithms
        - Input/output format requirements

        Extract ACTUAL PATTERNS from the code, not generic best practices.
        Focus on "this is how THIS project does it" not "this is how it should be done."
        Include specific examples from the actual code when possible.

        Full Context:
        """ + fullContext.toString();

    // LLM generates distilled summary
    String distilledSummary = llmService.distill(prompt);

    // Store distilled versions
    this.distilledSummary = distilledSummary;

    return distilledSummary;
}

// Helper to identify critical files
private boolean isCriticalFile(String filename) {
    return filename.contains("pom.xml") ||
           filename.contains("build.gradle") ||
           filename.contains("application.") ||
           filename.contains("Config") ||
           filename.contains("schema") ||
           filename.contains(".properties");
}
```

### 5. Benefits

#### Efficiency
- Quick context loading for simple decisions
- Reduced token usage in AI prompts
- Faster initial analysis

#### Flexibility
- Full details available when needed
- No loss of information
- Agents can choose their depth level

#### Maintainability
- No complex parsing in main code
- AI interprets raw content
- Easy to extend for new build systems

### 6. Implementation Steps

1. **Phase 1** (Current - Completed):
   - Store full build file content ✅
   - Remove complex parsing ✅
   - Let AI interpret raw content ✅

2. **Phase 2** (Future):
   - Add DistilledContext class
   - Implement distillation logic
   - Add storage for both tiers

3. **Phase 3** (Future):
   - Update TestWriterAgent to use distilled context
   - Add fallback to full context when needed
   - Optimize token usage

4. **Phase 4** (Future):
   - Add caching for distilled context
   - Implement lazy loading for full context
   - Add metrics for context usage patterns

### 7. Example Usage

#### Current (Simple) Approach:
```java
// ContextAgent stores everything
takeNote("[PROJECT_DEPENDENCIES] Complete dependency information from build files:\n" + fullContent);

// TestWriterAgent uses everything
String deps = contextTools.getProjectDependencies();
// AI interprets the full content
```

#### Future (Distilled) Approach:
```java
// ContextAgent stores both
takeNote("[DISTILLED_DEPS] Spring Boot 2.7, JUnit 5, Mockito, TestContainers, H2");
storeFullContext("pom.xml", fullContent);

// TestWriterAgent uses distilled
String quickDeps = contextTools.getDistilledDependencies();
// "Spring Boot web app with JPA, uses JUnit 5 and TestContainers"

// If needed, access full:
String pomDetail = contextTools.getFullBuildFile("pom.xml");
```

### 8. Context Reference Format

For agents that need to reference full context, use a special syntax:

```
@context:full:pom.xml       // Access full pom.xml content
@context:full:dependencies  // Access all dependency files
@context:distilled          // Access distilled summary
```

This allows agents to be explicit about their context needs while keeping the default behavior simple and efficient.

## Conclusion

This design provides a flexible, extensible system for managing context at different levels of detail. The current implementation (Phase 1) already provides the foundation by storing complete build files, and future phases can build upon this to add distillation and optimization features.