package com.zps.zest.testgen.ui

import com.intellij.openapi.actionSystem.*
import com.intellij.openapi.diagnostic.Logger
import com.intellij.openapi.fileEditor.FileEditor
import com.intellij.openapi.fileEditor.FileEditorLocation
import com.intellij.openapi.fileEditor.FileEditorState
import com.intellij.openapi.project.Project
import com.intellij.openapi.ui.DialogWrapper
import com.intellij.openapi.ui.Messages
import com.intellij.openapi.util.UserDataHolderBase
import com.intellij.openapi.vfs.VirtualFile
import com.intellij.ui.JBSplitter
import com.intellij.ui.components.*
import com.intellij.util.ui.JBUI
import com.intellij.util.ui.UIUtil
import com.zps.zest.testgen.TestGenerationService
import com.zps.zest.testgen.model.*
import com.zps.zest.testgen.ui.model.*
import com.zps.zest.testgen.ui.panels.*
import com.zps.zest.testgen.ui.dialogs.SessionResumeDialog
import com.zps.zest.testgen.ui.dialogs.MergedTestPreviewDialog
import com.zps.zest.testgen.ui.persistence.*
import com.zps.zest.testgen.ui.model.SerializableTestGenerationRequest
import java.awt.*
import java.awt.datatransfer.StringSelection
import java.beans.PropertyChangeListener
import javax.swing.*
import javax.swing.border.EmptyBorder
import javax.swing.border.TitledBorder
import com.intellij.openapi.application.ApplicationManager
import com.intellij.openapi.application.ModalityState
import java.util.concurrent.atomic.AtomicBoolean

/**
 * Test Generation Editor using improved LangChain4j agents.
 * Clean UI with real-time streaming display.
 */
class TestGenerationEditor(
    private val project: Project,
    private val virtualFile: TestGenerationVirtualFile
) : UserDataHolderBase(), FileEditor {
    
    companion object {
        private val LOG = Logger.getInstance(TestGenerationEditor::class.java)
    }
    
    private val testGenService = project.getService(TestGenerationService::class.java)
    private val component: JPanel
    private var currentSession: TestGenerationSession? = null
    private var streamingHelper: StreamingUIHelper? = null
    private var loadedSessionData: SessionSerializer.SessionRestorationData? = null
    
    // UI Components
    private lateinit var tabbedPane: JBTabbedPane
    private lateinit var streamingArea: JBTextArea
    private lateinit var statusLabel: JBLabel
    private lateinit var progressBar: JProgressBar
    
    // New specialized panels
    private lateinit var contextDisplayPanel: ContextDisplayPanel
    private lateinit var testPlanDisplayPanel: TestPlanDisplayPanel
    private lateinit var generatedTestsPanel: GeneratedTestsPanel
    
    // State
    private val scenarioSelectionShown = AtomicBoolean(false)
    
    // Event listener for structured updates from agents
    private lateinit var eventListener: StreamingEventListener
    
    init {
        component = JPanel(BorderLayout())
        component.background = UIUtil.getPanelBackground()
        setupUI()
        initializeStreamingHelper()
        
        // Auto-start test generation if we have a valid request
        virtualFile.request?.let { request ->
            SwingUtilities.invokeLater {
                startTestGeneration()
            }
        }
    }
    
    override fun getComponent(): JComponent = component
    override fun getPreferredFocusedComponent(): JComponent? = component
    override fun getName(): String = "Test Generation"
    override fun isValid(): Boolean = true
    override fun isModified(): Boolean = false
    override fun addPropertyChangeListener(listener: PropertyChangeListener) {}
    override fun removePropertyChangeListener(listener: PropertyChangeListener) {}
    override fun getCurrentLocation(): FileEditorLocation? = null
    override fun dispose() {}
    override fun setState(state: FileEditorState) {}
    override fun getFile(): VirtualFile = virtualFile
    
    private fun setupUI() {
        // Top toolbar
        component.add(createToolbar(), BorderLayout.NORTH)
        
        // Main content with splitter - tabs primary, streaming secondary
        val splitter = JBSplitter(true, 0.7f)
        
        // Top: Tabbed panels (primary focus)
        splitter.firstComponent = createTabbedPane()
        
        // Bottom: Streaming area (secondary, minimal height)
        splitter.secondComponent = createStreamingPanel()
        
        component.add(splitter, BorderLayout.CENTER)
        
        // Bottom status bar
        component.add(createStatusBar(), BorderLayout.SOUTH)
    }
    
    private fun createToolbar(): JComponent {
        val toolbar = JPanel(FlowLayout(FlowLayout.LEFT))
        toolbar.border = EmptyBorder(5, 5, 5, 5)
        
        // Start button
        val startButton = JButton("Start Test Generation")
        startButton.addActionListener { startTestGeneration() }
        toolbar.add(startButton)
        
        // Continue button (for resuming incomplete sessions)
        val continueButton = JButton("Continue Generation")
        continueButton.toolTipText = "Continue generating remaining test scenarios"
        continueButton.addActionListener { continueIncompleteGeneration() }
        toolbar.add(continueButton)
        
        // Cancel button
        val cancelButton = JButton("Cancel")
        cancelButton.addActionListener { cancelGeneration() }
        toolbar.add(cancelButton)
        
        // Save tests button
        val saveButton = JButton("Save Tests")
        saveButton.addActionListener { saveGeneratedTests() }
        toolbar.add(saveButton)
        
        // Copy button
        val copyButton = JButton("Copy to Clipboard")
        copyButton.addActionListener { copyToClipboard() }
        toolbar.add(copyButton)
        
        toolbar.add(JSeparator(JSeparator.VERTICAL))
        
        // Save session button
        val saveSessionButton = JButton("Save Session")
        saveSessionButton.addActionListener { saveSession() }
        toolbar.add(saveSessionButton)
        
        // Load session button
        val loadSessionButton = JButton("Load Session")
        loadSessionButton.addActionListener { loadSession() }
        toolbar.add(loadSessionButton)
        
        return toolbar
    }
    
    private fun createStreamingPanel(): JComponent {
        val panel = JPanel(BorderLayout())
        panel.border = TitledBorder("System Activity Log")
        
        // Streaming text area
        streamingArea = JBTextArea()
        streamingArea.isEditable = false
        streamingArea.font = Font(Font.MONOSPACED, Font.PLAIN, 12)
        streamingArea.background = UIUtil.getTextFieldBackground()
        
        val scrollPane = JBScrollPane(streamingArea)
        scrollPane.verticalScrollBarPolicy = ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS
        
        panel.add(scrollPane, BorderLayout.CENTER)
        
        // Control panel
        val controlPanel = JPanel(FlowLayout(FlowLayout.RIGHT))
        
        val clearButton = JButton("Clear")
        clearButton.addActionListener { streamingArea.text = "" }
        controlPanel.add(clearButton)
        
        val autoScrollCheckbox = JCheckBox("Auto-scroll", true)
        controlPanel.add(autoScrollCheckbox)
        
        panel.add(controlPanel, BorderLayout.SOUTH)
        
        return panel
    }
    
    private fun createTabbedPane(): JComponent {
        tabbedPane = JBTabbedPane()
        
        // Context tab - using new specialized panel
        contextDisplayPanel = ContextDisplayPanel(project)
        tabbedPane.addTab("Context", contextDisplayPanel)
        
        // Test Plan tab - using new specialized panel
        testPlanDisplayPanel = TestPlanDisplayPanel(project)
        testPlanDisplayPanel.setSelectionListener { selectedIds ->
            // Handle scenario selection changes if needed
            LOG.info("Selected scenarios: ${selectedIds.size}")
        }
        tabbedPane.addTab("Test Plan", testPlanDisplayPanel)
        
        // Generated Tests tab - using new specialized panel
        generatedTestsPanel = GeneratedTestsPanel(project)
        tabbedPane.addTab("Generated Tests", generatedTestsPanel)
        
        return tabbedPane
    }
    
    private fun createStatusBar(): JComponent {
        val statusBar = JPanel(BorderLayout())
        statusBar.border = EmptyBorder(5, 10, 5, 10)
        statusBar.preferredSize = Dimension(0, 30)
        
        // Status label
        statusLabel = JBLabel("Ready")
        statusBar.add(statusLabel, BorderLayout.WEST)
        
        // Progress bar
        progressBar = JProgressBar()
        progressBar.isStringPainted = true
        progressBar.preferredSize = Dimension(200, 20)
        statusBar.add(progressBar, BorderLayout.EAST)
        
        return statusBar
    }
    
    private fun initializeStreamingHelper() {
        // Initialize the event listener
        eventListener = object : StreamingEventListener {
                override fun onFileAnalyzed(data: ContextDisplayData) {
                    contextDisplayPanel.addFile(data)
                }
                
                override fun onTestPlanUpdated(data: TestPlanDisplayData) {
                    testPlanDisplayPanel.updateTestPlan(data)
                    // Switch to test plan tab
                    SwingUtilities.invokeLater {
                        tabbedPane.selectedIndex = 1
                    }
                }
                
                override fun onTestGenerated(data: GeneratedTestDisplayData) {
                    generatedTestsPanel.addGeneratedTest(data)
                }
                
                override fun onStatusChanged(status: String) {
                    updateStatus(status)
                }
                
                override fun onProgressChanged(percent: Int, message: String) {
                    updateProgress(percent, message)
                }
            }
        
        // Initialize the streaming helper with the event listener
        streamingHelper = StreamingUIHelper(eventListener)
    }
    
    private fun startTestGeneration() {
        val request = virtualFile.request ?: run {
            Messages.showErrorDialog(project, "No test generation request found", "Error")
            return
        }
        
        // Reset UI
        streamingArea.text = ""
        streamingHelper?.reset()
        scenarioSelectionShown.set(false)
        
        // Clear all panels
        contextDisplayPanel.clear()
        testPlanDisplayPanel.clear()
        generatedTestsPanel.clear()
        
        updateStatus("Starting test generation...")
        
        // Start generation with streaming, event listener, and completion callback
        val future = testGenService.startTestGeneration(request, { streamingText ->
            SwingUtilities.invokeLater {
                // Append to streaming area
                streamingArea.append(streamingText)
                
                // Auto-scroll if enabled
                streamingArea.caretPosition = streamingArea.document.length
                
                // Process with helper
                streamingHelper?.processStreamingText(streamingText)
                
                // The StreamingUIHelper now handles all parsing and panel updates
                // through the event listener interface
                
                // Check for scenario selection needed
                checkForScenarioSelection(streamingText)
            }
        }, eventListener) { completedSession ->
            // Completion callback - auto-show preview dialog
            showMergedTestPreview(completedSession)
        }
        
        future.thenAccept { session ->
            currentSession = session
            LOG.info("Test generation session started: ${session.sessionId}")
        }.exceptionally { throwable ->
            SwingUtilities.invokeLater {
                Messages.showErrorDialog(
                    project,
                    "Failed to start test generation: ${throwable.message}",
                    "Error"
                )
                updateStatus("Generation failed")
            }
            null
        }
    }
    
    private fun checkForScenarioSelection(text: String) {
        // Check if we're in the awaiting selection phase
        if (text.contains("Test Plan Summary") && !scenarioSelectionShown.get()) {
            currentSession?.let { session ->
                if (session.status == TestGenerationSession.Status.AWAITING_USER_SELECTION) {
                    scenarioSelectionShown.set(true)
                    SwingUtilities.invokeLater {
                        showScenarioSelectionDialog(session)
                    }
                }
            }
        }
    }
    
    private fun showScenarioSelectionDialog(session: TestGenerationSession) {
        val testPlan = session.testPlan ?: return
        
        val dialog = ScenarioSelectionDialog(project, testPlan)
        if (dialog.showAndGet()) {
            val selectedScenarios = dialog.getSelectedScenarios()
            if (selectedScenarios.isNotEmpty()) {
                // Update progress display
                generatedTestsPanel.showProgress(0, selectedScenarios.size)
                
                // Continue with selected scenarios
                testGenService.continueWithSelectedScenarios(
                    session.sessionId,
                    selectedScenarios,
                    eventListener
                )
                updateStatus("Generating tests for ${selectedScenarios.size} scenarios...")
            }
        }
    }
    
    // These methods are no longer needed as the new panels handle display internally
    
    private fun updateStatus(status: String) {
        SwingUtilities.invokeLater {
            statusLabel.text = status
        }
    }
    
    private fun updateProgress(percent: Int, message: String) {
        SwingUtilities.invokeLater {
            progressBar.value = percent
            progressBar.string = message
            progressBar.isIndeterminate = percent == 0
        }
    }
    
    private fun showMergedTestPreview(session: TestGenerationSession) {
        if (session.status == TestGenerationSession.Status.COMPLETED && session.mergedTestClass != null) {
            val dialog = MergedTestPreviewDialog(project, session)
            dialog.show()
        }
    }
    
    
    private fun continueIncompleteGeneration() {
        val sessionData = loadedSessionData
        if (sessionData == null) {
            Messages.showWarningDialog(
                project,
                "No session loaded. Please load a session first.",
                "Continue Generation"
            )
            return
        }
        
        val testPlan = sessionData.testPlanData
        if (testPlan == null) {
            Messages.showWarningDialog(
                project,
                "No test plan found in the loaded session.",
                "Continue Generation"
            )
            return
        }
        
        // Find remaining scenarios
        val generatedTestIds = sessionData.generatedTests.map { it.scenarioId }.toSet()
        val remainingScenarios = testPlan.scenarios.filter { scenario ->
            scenario.id !in generatedTestIds && 
            scenario.generationStatus != ScenarioDisplayData.GenerationStatus.SKIPPED
        }
        
        if (remainingScenarios.isEmpty()) {
            Messages.showInfoMessage(
                project,
                "All test scenarios have been completed or skipped.",
                "Continue Generation"
            )
            return
        }
        
        // Show confirmation dialog
        val message = buildString {
            appendLine("Found ${remainingScenarios.size} incomplete scenarios:")
            appendLine()
            remainingScenarios.take(5).forEach { scenario ->
                appendLine("  • ${scenario.name}")
            }
            if (remainingScenarios.size > 5) {
                appendLine("  ... and ${remainingScenarios.size - 5} more")
            }
            appendLine()
            appendLine("Continue generating these tests?")
        }
        
        val result = Messages.showYesNoDialog(
            project,
            message,
            "Continue Generation",
            Messages.getQuestionIcon()
        )
        
        if (result == Messages.YES) {
            resumeTestGeneration(sessionData, remainingScenarios)
        }
    }
    
    private fun cancelGeneration() {
        currentSession?.let { session ->
            testGenService.cancelSession(session.sessionId)
            updateStatus("🛑 Generation cancelled")
            progressBar.value = 0
        }
    }
    
    private fun saveGeneratedTests() {
        currentSession?.let { session ->
            testGenService.writeTestsToFiles(session.sessionId).thenAccept { files ->
                SwingUtilities.invokeLater {
                    if (files.isNotEmpty()) {
                        Messages.showInfoMessage(
                            project,
                            "Saved ${files.size} test file(s):\n${files.joinToString("\n")}",
                            "Tests Saved"
                        )
                    } else {
                        Messages.showWarningDialog(
                            project,
                            "No tests to save",
                            "Warning"
                        )
                    }
                }
            }
        }
    }
    
    private fun copyToClipboard() {
        val content = streamingArea.text
        if (content.isNotEmpty()) {
            val clipboard = Toolkit.getDefaultToolkit().systemClipboard
            clipboard.setContents(StringSelection(content), null)
            updateStatus("Copied to clipboard")
        }
    }
    
    private fun saveSession() {
        currentSession?.let { session ->
            try {
                val repository = SessionRepository.getInstance(project)
                
                // Collect current UI state
                val requestData = session.request?.let { req ->
                    SessionSerializer.SerializableRequestData(
                        targetFilePath = req.targetFile.virtualFile?.path ?: "",
                        targetMethodNames = req.targetMethods.mapNotNull { it.name },
                        selectedCode = req.selectedCode,
                        testType = req.testType.name,
                        additionalContext = req.additionalContext
                    )
                }
                
                val sessionData = SessionSerializer.SessionRestorationData(
                    sessionId = session.sessionId,
                    createdAt = session.createdAt,
                    status = session.status.name,
                    contextFiles = getContextFiles(),
                    testPlanData = getTestPlanData(),
                    generatedTests = getGeneratedTests(),
                    progressPercent = progressBar.value,
                    currentPhase = streamingHelper?.getCurrentPhase() ?: "IDLE",
                    metadata = mapOf(
                        "targetFile" to virtualFile.name,
                        "targetFilePath" to (session.request.targetFile.virtualFile?.path ?: ""),
                        "targetClass" to (testPlanDisplayPanel.getTestPlanData()?.targetClass ?: "unknown"),
                        "requestData" to (requestData ?: emptyMap<String, Any>()),
                        "streamingLog" to streamingArea.text.take(10000) // Limit size
                    )
                )
                
                val result = repository.saveSession(sessionData)
                result.fold(
                    onSuccess = { file ->
                        Messages.showInfoMessage(
                            project,
                            "Session saved successfully:\n${file.name}",
                            "Session Saved"
                        )
                    },
                    onFailure = { error ->
                        Messages.showErrorDialog(
                            project,
                            "Failed to save session: ${error.message}",
                            "Save Error"
                        )
                    }
                )
            } catch (e: Exception) {
                Messages.showErrorDialog(
                    project,
                    "Error saving session: ${e.message}",
                    "Save Error"
                )
            }
        } ?: Messages.showWarningDialog(
            project,
            "No active session to save",
            "Save Session"
        )
    }
    
    private fun loadSession() {
        val dialog = SessionResumeDialog(project)
        if (dialog.showAndGet()) {
            dialog.getSelectedSessionFileName()?.let { fileName ->
                val repository = SessionRepository.getInstance(project)
                val result = repository.loadSession(fileName)
                
                result.fold(
                    onSuccess = { sessionData ->
                        restoreSession(sessionData)
                        Messages.showInfoMessage(
                            project,
                            "Session restored successfully",
                            "Session Loaded"
                        )
                    },
                    onFailure = { error ->
                        Messages.showErrorDialog(
                            project,
                            "Failed to load session: ${error.message}",
                            "Load Error"
                        )
                    }
                )
            }
        }
    }
    
    private fun restoreSession(sessionData: SessionSerializer.SessionRestorationData) {
        // Store the loaded session data for potential resumption
        loadedSessionData = sessionData
        
        // Clear current state
        streamingArea.text = ""
        contextDisplayPanel.clear()
        testPlanDisplayPanel.clear()
        generatedTestsPanel.clear()
        
        // Restore UI state
        sessionData.contextFiles.forEach { file ->
            contextDisplayPanel.addFile(file)
        }
        
        sessionData.testPlanData?.let { plan ->
            testPlanDisplayPanel.updateTestPlan(plan)
        }
        
        sessionData.generatedTests.forEach { test ->
            generatedTestsPanel.addGeneratedTest(test)
        }
        
        // Restore progress
        progressBar.value = sessionData.progressPercent
        
        // Build informative status message
        val targetFile = sessionData.metadata["targetFile"]?.toString() ?: "unknown"
        val targetClass = sessionData.metadata["targetClass"]?.toString() ?: "unknown"
        val filesAnalyzed = sessionData.contextFiles.size
        val testsGenerated = sessionData.generatedTests.size
        
        updateStatus("Session restored: $targetClass ($filesAnalyzed files, $testsGenerated tests)")
        
        // Show streaming log if available with session info header
        val sessionInfo = buildString {
            appendLine("=".repeat(60))
            appendLine("SESSION RESTORED")
            appendLine("Session ID: ${sessionData.sessionId}")
            appendLine("Target File: $targetFile")
            appendLine("Target Class: $targetClass")
            sessionData.metadata["targetFilePath"]?.toString()?.let {
                appendLine("File Path: $it")
            }
            appendLine("Progress: ${sessionData.progressPercent}%")
            appendLine("Phase: ${sessionData.currentPhase}")
            appendLine("Files Analyzed: $filesAnalyzed")
            appendLine("Tests Generated: $testsGenerated")
            appendLine("=".repeat(60))
            appendLine()
        }
        
        val log = sessionData.metadata["streamingLog"] as? String ?: ""
        streamingArea.text = sessionInfo + log
        
        // If we have test plan data, switch to that tab
        if (sessionData.testPlanData != null) {
            tabbedPane.selectedIndex = 1  // Test Plan tab
        } else if (sessionData.contextFiles.isNotEmpty()) {
            tabbedPane.selectedIndex = 0  // Context tab
        }
        
        // Check if session can be resumed (has test plan but not all tests generated)
        if (sessionData.testPlanData != null && sessionData.status != "COMPLETED") {
            checkForResumableSession(sessionData)
        }
    }
    
    private fun checkForResumableSession(sessionData: SessionSerializer.SessionRestorationData) {
        val testPlan = sessionData.testPlanData ?: return
        val generatedTestIds = sessionData.generatedTests.map { it.scenarioId }.toSet()
        val remainingScenarios = testPlan.scenarios.filter { scenario ->
            scenario.id !in generatedTestIds && 
            scenario.generationStatus != ScenarioDisplayData.GenerationStatus.SKIPPED
        }
        
        if (remainingScenarios.isNotEmpty()) {
            SwingUtilities.invokeLater {
                val message = buildString {
                    appendLine("This session has incomplete test generation:")
                    appendLine()
                    appendLine("✅ Completed: ${sessionData.generatedTests.size} tests")
                    appendLine("⏳ Remaining: ${remainingScenarios.size} scenarios")
                    appendLine()
                    appendLine("Remaining scenarios:")
                    remainingScenarios.take(5).forEach { scenario ->
                        appendLine("  • ${scenario.name}")
                    }
                    if (remainingScenarios.size > 5) {
                        appendLine("  ... and ${remainingScenarios.size - 5} more")
                    }
                    appendLine()
                    appendLine("Options:")
                    appendLine("• YES - Resume generation for remaining scenarios")
                    appendLine("• NO - View completed tests only")
                }
                
                val result = Messages.showYesNoDialog(
                    project,
                    message,
                    "Resume Test Generation?",
                    Messages.getQuestionIcon()
                )
                
                if (result == Messages.YES) {
                    resumeTestGeneration(sessionData, remainingScenarios)
                } else {
                    // Mark remaining scenarios as skipped in UI
                    markRemainingAsSkipped(remainingScenarios)
                }
            }
        }
    }
    
    private fun markRemainingAsSkipped(remainingScenarios: List<ScenarioDisplayData>) {
        // Update the test plan display to show skipped scenarios
        testPlanDisplayPanel.getTestPlanData()?.let { planData ->
            val updatedScenarios = planData.scenarios.map { scenario ->
                if (remainingScenarios.any { it.id == scenario.id }) {
                    scenario.copy(generationStatus = ScenarioDisplayData.GenerationStatus.SKIPPED)
                } else {
                    scenario
                }
            }
            val updatedPlan = planData.copy(scenarios = updatedScenarios)
            testPlanDisplayPanel.updateTestPlan(updatedPlan)
        }
        
        updateStatus("Session loaded - ${remainingScenarios.size} scenarios skipped")
    }
    
    private fun resumeTestGeneration(
        sessionData: SessionSerializer.SessionRestorationData,
        remainingScenarios: List<ScenarioDisplayData>
    ) {
        // Reconstruct the request from saved data
        val request = reconstructRequest(sessionData)
        if (request == null) {
            Messages.showErrorDialog(
                project,
                "Cannot resume: Unable to reconstruct test generation request.\nThe target file may have been moved or deleted.",
                "Resume Error"
            )
            return
        }
        
        updateStatus("Resuming test generation for ${remainingScenarios.size} scenarios...")
        progressBar.value = sessionData.progressPercent
        
        // Show which scenarios will be generated
        streamingArea.append("\n\n")
        streamingArea.append("=".repeat(60) + "\n")
        streamingArea.append("RESUMING TEST GENERATION\n")
        streamingArea.append("Remaining scenarios to generate:\n")
        remainingScenarios.forEach { scenario ->
            streamingArea.append("  - ${scenario.name} [${scenario.priority.displayName}]\n")
        }
        streamingArea.append("=".repeat(60) + "\n\n")
        
        // Start a new session but indicate it's a continuation
        val future = testGenService.startTestGeneration(request, { streamingText ->
            SwingUtilities.invokeLater {
                streamingArea.append(streamingText)
                streamingArea.caretPosition = streamingArea.document.length
                streamingHelper?.processStreamingText(streamingText)
                
                // Check if we've reached the scenario selection phase
                if (streamingText.contains("Test Plan Summary") && !scenarioSelectionShown.get()) {
                    // Auto-select only the remaining scenarios
                    currentSession?.let { session ->
                        if (session.status == TestGenerationSession.Status.AWAITING_USER_SELECTION) {
                            scenarioSelectionShown.set(true)
                            SwingUtilities.invokeLater {
                                // Auto-continue with remaining scenarios
                                autoSelectRemainingScenarios(session, remainingScenarios, sessionData)
                            }
                        }
                    }
                }
            }
        }, eventListener)
        
        future.thenAccept { session ->
            currentSession = session
            LOG.info("Resumed test generation session: ${session.sessionId}")
        }.exceptionally { throwable ->
            SwingUtilities.invokeLater {
                Messages.showErrorDialog(
                    project,
                    "Failed to resume test generation: ${throwable.message}",
                    "Resume Error"
                )
                updateStatus("Resume failed")
            }
            null
        }
    }
    
    private fun autoSelectRemainingScenarios(
        session: TestGenerationSession,
        remainingScenarios: List<ScenarioDisplayData>,
        sessionData: SessionSerializer.SessionRestorationData
    ) {
        val testPlan = session.testPlan ?: return
        
        // Map remaining scenario IDs to actual TestPlan scenarios
        val remainingIds = remainingScenarios.map { it.id }.toSet()
        val scenariosToGenerate = testPlan.testScenarios.filter { scenario ->
            val scenarioId = "scenario_${scenario.name.hashCode()}"
            scenarioId in remainingIds
        }
        
        if (scenariosToGenerate.isNotEmpty()) {
            // Update progress display
            generatedTestsPanel.showProgress(
                sessionData.generatedTests.size,
                sessionData.generatedTests.size + scenariosToGenerate.size
            )
            
            // Continue with selected scenarios
            testGenService.continueWithSelectedScenarios(
                session.sessionId,
                scenariosToGenerate,
                eventListener
            )
            
            updateStatus("Generating ${scenariosToGenerate.size} remaining tests...")
        }
    }
    
    private fun getContextFiles(): List<ContextDisplayData> {
        return contextDisplayPanel.getContextFiles()
    }
    
    private fun getTestPlanData(): TestPlanDisplayData? {
        return testPlanDisplayPanel.getTestPlanData()
    }
    
    private fun getGeneratedTests(): List<GeneratedTestDisplayData> {
        return generatedTestsPanel.getGeneratedTests()
    }
    
    /**
     * Reconstruct a TestGenerationRequest from saved session data
     */
    private fun reconstructRequest(sessionData: SessionSerializer.SessionRestorationData): TestGenerationRequest? {
        val requestData = sessionData.metadata["requestData"]
        
        return when (requestData) {
            is SessionSerializer.SerializableRequestData -> {
                SerializableTestGenerationRequest.toRequest(
                    project,
                    SerializableTestGenerationRequest(
                        targetFilePath = requestData.targetFilePath,
                        targetMethodNames = requestData.targetMethodNames,
                        selectedCode = requestData.selectedCode,
                        testType = requestData.testType,
                        additionalContext = requestData.additionalContext
                    )
                )
            }
            is Map<*, *> -> {
                // Try to reconstruct from map
                val targetFilePath = requestData["targetFilePath"]?.toString() ?: return null
                val targetMethodNames = (requestData["targetMethodNames"] as? List<*>)?.mapNotNull { it?.toString() } ?: emptyList()
                val selectedCode = requestData["selectedCode"]?.toString()
                val testType = requestData["testType"]?.toString() ?: "AUTO_DETECT"
                val additionalContext = (requestData["additionalContext"] as? Map<*, *>)?.mapNotNull { (k, v) ->
                    k?.toString()?.let { key -> key to v.toString() }
                }?.toMap() ?: emptyMap()
                
                SerializableTestGenerationRequest.toRequest(
                    project,
                    SerializableTestGenerationRequest(
                        targetFilePath = targetFilePath,
                        targetMethodNames = targetMethodNames,
                        selectedCode = selectedCode,
                        testType = testType,
                        additionalContext = additionalContext
                    )
                )
            }
            else -> {
                // Fallback: try to reconstruct from basic metadata
                val targetFilePath = sessionData.metadata["targetFilePath"]?.toString() ?: return null
                
                SerializableTestGenerationRequest.toRequest(
                    project,
                    SerializableTestGenerationRequest(
                        targetFilePath = targetFilePath,
                        targetMethodNames = emptyList(),
                        selectedCode = null,
                        testType = "AUTO_DETECT",
                        additionalContext = emptyMap()
                    )
                )
            }
        }
    }
    
    /**
     * Dialog for selecting which test scenarios to generate.
     */
    private class ScenarioSelectionDialog(
        project: Project,
        private val testPlan: TestPlan
    ) : DialogWrapper(project) {
        
        private val checkBoxes = mutableListOf<JCheckBox>()
        
        init {
            title = "Select Test Scenarios"
            init()
        }
        
        override fun createCenterPanel(): JComponent {
            val panel = JPanel()
            panel.layout = BoxLayout(panel, BoxLayout.Y_AXIS)
            panel.border = EmptyBorder(10, 10, 10, 10)
            
            // Header
            val header = JBLabel("<html><h3>Select scenarios to generate tests for:</h3></html>")
            panel.add(header)
            panel.add(Box.createVerticalStrut(10))
            
            // Scenario checkboxes
            testPlan.testScenarios.forEach { scenario ->
                val checkBox = JCheckBox(scenario.name, true)
                checkBox.toolTipText = scenario.description
                checkBoxes.add(checkBox)
                
                val scenarioPanel = JPanel(FlowLayout(FlowLayout.LEFT))
                scenarioPanel.add(checkBox)
                
                val priorityLabel = JBLabel("[${scenario.priority.displayName}]")
                priorityLabel.foreground = when (scenario.priority) {
                    TestPlan.TestScenario.Priority.HIGH -> Color.RED
                    TestPlan.TestScenario.Priority.MEDIUM -> Color.ORANGE
                    TestPlan.TestScenario.Priority.LOW -> Color.GREEN
                }
                scenarioPanel.add(priorityLabel)
                
                panel.add(scenarioPanel)
            }
            
            // Select all/none buttons
            panel.add(Box.createVerticalStrut(10))
            val buttonPanel = JPanel(FlowLayout(FlowLayout.CENTER))
            
            val selectAllButton = JButton("Select All")
            selectAllButton.addActionListener {
                checkBoxes.forEach { it.isSelected = true }
            }
            buttonPanel.add(selectAllButton)
            
            val selectNoneButton = JButton("Select None")
            selectNoneButton.addActionListener {
                checkBoxes.forEach { it.isSelected = false }
            }
            buttonPanel.add(selectNoneButton)
            
            panel.add(buttonPanel)
            
            return JBScrollPane(panel)
        }
        
        fun getSelectedScenarios(): List<TestPlan.TestScenario> {
            return checkBoxes.mapIndexedNotNull { index, checkBox ->
                if (checkBox.isSelected) testPlan.testScenarios[index] else null
            }
        }
    }
}